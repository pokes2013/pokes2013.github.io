# 3.7.内部类

内部类：就是在一个类中定义一个类

## 内部类的访问特点

* 内部类可以直接访问外部类的成员，包括私有；

* 外部类要访问内部类的成员，必须创建对象

```java
package com.pokes011;

public class Outer {
    private int num = 10;

    public class Inner {
        public void show() {
            System.out.println(num);
        }
    }

    public void method(){
        //show(); 报错，不能直接访问内部类中的成员
        // 只能先创建内部类的对象再访问
        Inner i =new Inner();
        i.show();
    }
}

```

## 成员内部类

按照内部类在类中定义的位置不同，可以分为如下两种形式

* 在类的成员位置：成员内部类

* 在类的局部位置：局部内部类

```java
package com.pokes011;

public class Outer {
    private int num = 10;

    public class Inner {
        public void show() {
            System.out.println(num);
        }
    }

    public void method(){
        //show(); 报错，外部类不能直接访问内部类中的成员
        // 只能先创建内部类的对象再访问
        Inner i =new Inner();
        i.show();
    }
}


package com.pokes011;

public class Demo {
    public static void main(String[] args) {
        //创建内部类对象，并调用
        Outer.Inner oi = new Outer().new Inner();
        oi.show();
    }

}
```

但是一般情况下内部类所用修饰符并不是public，这种情况如下：

```java
package com.pokes011;
//外部类
public class Outer {
    private int num = 10;
	//内部类
    private class Inner {
        public void show() {
            System.out.println(num);
        }
    }

    public void method(){
        //show(); 报错，外部类不能直接访问内部类中的成员
        // 只能先创建内部类的对象再访问
        Inner i =new Inner();
        i.show();
    }
}


package com.pokes011;
//测试类
public class Demo {
    public static void main(String[] args) {
        //创建内部类对象，并调用
        //Outer.Inner oi = new Outer().new Inner();
        //oi.show();

        //当内部类的修饰符变为private，上面的方法就不行了
        //我们可以创建外部类的对象，调用method方法间接性的调用内部类的方法
        Outer o = new Outer();
        o.method();
    }

}
```

## 局部类

局部内部类是在方法中定义的类，所以外界是无法直接使用，需要在方法内部创建对象并使用该类可以直接访问外部类的成员，也可以访问方法内的局部变量

```java
package com.pokes012;

//局部类

public class Outer {
    private int num1 = 10;

    public void method() {
        int num2=20;   //局部变量
        //局部类定义
        class Inner {
            public void show() {
                System.out.println(num1);
                System.out.println(num2);
            }
        }
        //局部类必须创建局部类的对象
        Inner i = new Inner();
        i.show();

    }
}



package com.pokes012;

//测试类
public class Demo {
    public static void main(String[] args) {
        Outer o = new Outer();
        o.method();  //10,20 注意：局部类必须创建在方法内创建对象，否则这里是无法输出的。
    }

}

```

## 匿名内部类

### 1.什么是匿名内部类？

隐藏了名字的内部类，可以写在成员位置，也可以写在局部位置

前提：存在一个类或者接口，这里的类可以是具体的类也可以是抽象类。  
本质：是一个继承了该类或者实现了该接口的子类匿名的对象，没错本质==他是一个对象==。

### 2.匿名内部类书写格式

```java
new 类名或者接口名() {
	重写方法；
}
```

### 3.格式的细节

包含了继承或实现，方法重写，创建对象。  
整体就是一个类的子类对象或者接口的实现类对象

### 4．使用场景

当方法的参数是接口或者类时，以接口为例，可以传递这个接口的实现类对象，如果实现类只要使用一次，就可以用匿名内部类简化代码。

### 5.举例1

```java
package com.pokes013;

public interface Swim {
    public abstract void swim();
}

package com.pokes013;

public class Demo {

    public static void main(String[] args) {



        //匿名内部类：
        //1.匿名内部类中包含了对象的创建；
        //2.匿名内部类中包含了方法的重写；
        //3.匿名内部类中包含了接口的实现；

        new Swim() {
            @Override
            public void swim() {
                System.out.println("重写了游泳的方法");
            }
        };
    }

}


```

### 6.匿名内部类在开发中的使用

现在有一个接口Jumpping，内有一个方法jump

```java
package com.pokes013;
//接口
public interface Jumpping {
    void jump();
}
```

接口操作类JumppingOperator，内有一个方法method，需要注意的是这里的method方法需要传入的参数是一个Jumpping接口的对象。

```java
package com.pokes013;
//接口操作类
public class JumppingOperator {
    public void method(Jumpping j){
        j.jump();
    }
}

```

测试类

```java
package com.pokes013;

public class JumppingDemo {
    public static void main(String[] args) {
        JumppingOperator jo =new JumppingOperator();
        //method方法的参数是一个对象，所以调用之前必须先创建Jumpping对象j，直接是无法调用的
        //jo.method();
    }
}
```

接下来我们创建Jumpping对象j，但是接口是抽象的，我们必须具体到一个非抽象的类，我们再次创建一个Cat类，让其实现Jumpping 的动作

```java
package com.pokes013;

public class Cat implements Jumpping {
    @Override
    public void jump() {
        System.out.println("猫可以跳高了");
    }
}

```

这样测试类就可以调用method了

```java
package com.pokes013;
//测试类
public class JumppingDemo {
    public static void main(String[] args) {
        JumppingOperator jo =new JumppingOperator();
        Jumpping j = new Cat();
        //method方法的参数是一个对象，所以调用之前必须先创建Jumpping对象j
        jo.method(j);
    }
}

```

这样就可以了，但是我们发现这样非常麻烦。我们每次创建实现接口都要创建相应的类，如果我们要实现狗跳高，还需要创建狗的类。有没有省事的方法呢？有的，根据上面的例子我们发现method方法的参数需要的是一个对象，而匿名内部类本质就是一个对象。那么我们的测试类就是如下这样即可。无需再创建具体的Cat类。

```java
package com.pokes013;
//测试类
public class JumppingDemo {
    public static void main(String[] args) {
        JumppingOperator jo =new JumppingOperator();
        jo.method(new Jumpping() {
            @Override
            public void jump() {
                System.out.println("猫可以跳高了");
            }
        });
    
    }
}

```
