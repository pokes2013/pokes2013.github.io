Docker（镜像制作、容器管理、Docker Compose）、Kubernetes（K8s）核心概念（Pod、Service、Deployment）、集群部署与运维


# Docker + Kubernetes(K8s) 全核心知识点梳理（镜像/容器/Compose + Pod/Service/Deployment + 集群运维）
你梳理的是后端/云原生开发的核心技术栈：**Docker全套核心（镜像制作+容器管理+Docker Compose）** + **Kubernetes核心概念（Pod/Service/Deployment）** + **K8s集群部署与运维**，下面是系统化、结构化的完整版知识点，全部是工作/面试高频核心内容，逻辑清晰、重点突出，可直接学习/复习。

---

## 一、Docker 核心全体系（镜像制作 + 容器管理 + Docker Compose）
### ✅ 1.1 核心认知：Docker 是什么 & 核心优势
Docker 是**容器化技术**的事实标准，是一个轻量级的「应用打包+部署+运行」的工具，核心是**将应用及其所有依赖（运行环境、配置、库文件）打包成一个独立的「容器」**。
- 核心优势：**一次构建、处处运行**，彻底解决「开发环境能跑、测试环境报错、生产环境崩了」的环境不一致问题；
- 核心区别：容器是**进程级虚拟化**（共享宿主机内核），比虚拟机（硬件级虚拟化）轻量100倍，启动毫秒级、资源占用极低。

### ✅ 1.2 Docker 三大核心组件（必背，基石）
Docker 体系的核心是「三位一体」，三者紧密关联，缺一不可，优先级：镜像 > 容器 > 仓库
1. **镜像 (Image)**：`只读的模板`，是容器的「源代码/安装包」，包含了运行应用的所有内容（系统环境、代码、依赖、配置），镜像不能被修改，是静态的。
2. **容器 (Container)**：`镜像的运行实例`，是镜像被 Docker 运行起来的「动态进程」，是隔离的、可读写的、独立的运行环境，删除容器不会影响镜像。
3. **仓库 (Registry)**：镜像的「仓库/网盘」，用于存储和分发镜像，比如公共仓库：Docker Hub（官方）、阿里云镜像仓库；私有仓库：公司内部搭建的 Harbor。

### ✅ 1.3 镜像制作（Dockerfile 核心，工作必备）
#### ✔️ 镜像制作的核心方式：编写 Dockerfile + 执行构建命令
**Dockerfile** 是一个**纯文本文件**，里面写满了「构建镜像的一条条指令」，Docker 会按照指令的顺序，一步步构建出镜像，是镜像制作的唯一核心方式。
##### （1）Dockerfile 核心指令（高频必记，按使用频率排序）
```dockerfile
FROM 基础镜像名:版本        # 必写！指定基础镜像，所有镜像都基于其他镜像构建，如 openjdk:8、python:3.9、nginx:alpine
WORKDIR /app               # 指定容器启动后的「工作目录」，后续命令都在该目录执行，推荐使用（替代cd）
COPY 宿主机路径 容器内路径  # 把宿主机的文件/目录复制到容器内
ADD 宿主机路径 容器内路径   # 功能同COPY，额外支持：自动解压压缩包、拉取网络文件
RUN 命令                   # 构建镜像时执行的命令，比如安装依赖、编译项目（如 mvn clean package）
EXPOSE 端口号              # 声明容器对外暴露的端口（只是声明，不会自动映射，启动容器时需加 -p 映射）
ENV KEY=VALUE              # 设置容器内的环境变量，运行时生效
CMD ["命令","参数"]         # 容器「启动时」执行的命令，一个Dockerfile只能有一个CMD，被docker run的命令覆盖
ENTRYPOINT ["命令","参数"]  # 容器「启动时」执行的命令，优先级高于CMD，不会被覆盖，适合做固定启动指令
```
##### （2）镜像构建与常用操作命令（高频实操）
```bash
# 构建镜像：-t 给镜像打标签（格式：仓库/镜像名:版本，版本默认latest），末尾的 . 是Dockerfile所在目录
docker build -t my-app:1.0 .

# 查看本地所有镜像
docker images / docker image ls

# 删除镜像（先删依赖该镜像的容器）
docker rmi 镜像ID/镜像名:版本

# 镜像打标签（用于推送仓库）
docker tag my-app:1.0 registry.xxx.com/my-app:1.0

# 推送镜像到仓库
docker push registry.xxx.com/my-app:1.0

# 拉取远程镜像
docker pull nginx:1.25
```

### ✅ 1.4 容器管理（全生命周期+核心命令，高频实操，重中之重）
容器是「镜像的运行态」，容器的**全生命周期**：`创建 → 启动 → 运行 → 暂停 → 重启 → 停止 → 删除`，Docker 提供了一站式命令管理，所有命令都是高频考点/工作必备！
#### ✔️ 容器核心操作命令（按使用频率排序，必会）
```bash
# 1. 最常用：创建+启动容器（推荐，一步到位）
# -d：后台运行容器（守护进程模式）；-p 宿主机端口:容器端口：端口映射（核心，外部访问容器必须配置）
# --name 容器名：给容器起别名；--rm：容器停止后自动删除容器（适合测试环境）
# 最后跟 镜像名:版本，指定基于哪个镜像启动
docker run -d -p 8080:8080 --name my-container my-app:1.0

# 2. 查看容器
docker ps          # 查看「正在运行」的容器
docker ps -a       # 查看「所有」容器（运行中+已停止）
docker ps -q       # 只显示容器ID（批量操作时用）

# 3. 容器启停/重启/暂停
docker start 容器ID/容器名   # 启动已停止的容器
docker stop 容器ID/容器名    # 优雅停止容器（推荐）
docker kill 容器ID/容器名    # 强制杀死容器进程（紧急情况用）
docker restart 容器ID/容器名 # 重启容器
docker pause 容器ID/容器名   # 暂停容器
docker unpause 容器ID/容器名 # 恢复暂停的容器

# 4. 进入容器内部（调试必备，容器是独立环境，需进入排查问题）
docker exec -it 容器ID/容器名 /bin/bash  # 进入Linux容器（最常用，-it：交互式终端）
docker exec -it 容器ID/容器名 sh         # 轻量镜像（alpine）用sh替代bash

# 5. 查看容器日志（排查容器运行报错的核心命令！）
docker logs 容器ID/容器名       # 查看容器日志
docker logs -f 容器ID/容器名    # 实时滚动查看日志（tail -f 效果）
docker logs --tail 100 容器ID   # 只看最后100行日志

# 6. 删除容器
docker rm 容器ID/容器名         # 删除「已停止」的容器
docker rm -f 容器ID/容器名      # 强制删除「正在运行」的容器（慎用）
docker rm $(docker ps -aq)     # 批量删除所有容器（测试环境清理用）

# 7. 查看容器详情（IP、端口、挂载、环境变量等）
docker inspect 容器ID/容器名
```

### ✅ 1.5 Docker Compose 核心（多容器编排工具，必学）
#### ✔️ 为什么需要 Docker Compose？
Docker run 只能管理**单个容器**，但实际项目中，一个应用往往依赖「多个容器」：比如一个Java项目，需要 `后端服务容器 + MySQL容器 + Redis容器 + Nginx容器`。
如果用 docker run 逐个启动，要配置大量参数（端口、网络、依赖关系），启动顺序错了还会报错，极其繁琐。

**Docker Compose 核心定位**：一个用于**定义和运行「多容器Docker应用」的工具**，用一个 `docker-compose.yml` 文件，**一次性编排、启动、停止、管理所有关联容器**，解决「多容器协同部署」的痛点。

#### ✔️ Docker Compose 核心使用流程（三步法，必会）
1. 编写 `docker-compose.yml` 文件（核心，定义所有容器的配置）；
2. 执行 `docker-compose up` 启动所有容器；
3. 执行 `docker-compose down` 停止并删除所有容器。

#### ✔️ docker-compose.yml 核心语法（最简实战版，够用）
```yaml
# 版本声明（固定，推荐3+）
version: '3'
# 定义所有服务（容器），services下的每个节点就是一个容器
services:
  # 服务1：后端应用
  app:
    build: ./          # 本地构建镜像，指定Dockerfile所在目录
    image: my-app:1.0  # 镜像名
    ports:
      - "8080:8080"    # 端口映射
    depends_on:
      - mysql          # 依赖mysql容器，启动时先启动mysql
    restart: always    # 容器挂了自动重启
  # 服务2：MySQL数据库
  mysql:
    image: mysql:8.0   # 直接使用远程镜像，无需构建
    ports:
      - "3306:3306"
    environment:       # 配置环境变量
      - MYSQL_ROOT_PASSWORD=123456
      - MYSQL_DATABASE=my_db
    volumes:
      - ./mysql-data:/var/lib/mysql  # 数据卷挂载，持久化MySQL数据
    restart: always
```
#### ✔️ Docker Compose 核心命令
```bash
docker-compose up -d   # 后台启动所有容器（核心命令）
docker-compose down    # 停止并删除所有容器+网络（核心命令）
docker-compose ps      # 查看当前编排的容器
docker-compose logs -f # 实时查看所有容器日志
docker-compose restart # 重启所有容器
docker-compose stop    # 停止所有容器（不删除）
```

---

## 二、Kubernetes (K8s) 核心认知 & 核心概念（Pod/Service/Deployment 三大基石，重中之重）
### ✅ 2.1 K8s 是什么 & 解决什么问题？
#### ✔️ 核心定位
Kubernetes（简称 K8s，因为 K和s之间有8个字母）是一个**开源的、用于自动化部署、扩缩容、管理「容器化应用」的集群编排平台**。
可以理解为：**Docker 是「单机管理容器」，K8s 是「集群化管理成千上万的容器」**。

#### ✔️ K8s 解决的核心痛点
Docker + Docker Compose 只能解决「单机」的容器管理问题，当业务规模变大，会遇到：
1. 容器挂了，需要手动重启 → K8s 自动重启；
2. 单机性能不够，需要多机部署 → K8s 支持集群，自动调度容器到不同机器；
3. 应用需要扩容/缩容 → K8s 一键扩缩容；
4. 容器IP是动态的，服务之间调用不稳定 → K8s 提供 Service 稳定访问；
5. 多容器协同、故障自愈、滚动更新、灰度发布 → K8s 一站式支持。

#### ✔️ 核心口号
`K8s 让容器化应用的部署和运维，变得像管理单机应用一样简单`。

### ✅ 2.2 K8s 核心原则（必记）
K8s 中**一切皆资源**，所有的操作（部署、扩容、更新）都是「对资源的声明式操作」：你只需要告诉 K8s 「你想要的最终状态是什么」，K8s 会自动帮你实现并维持这个状态，无需关心过程。
比如：你声明「我要3个应用实例」，K8s 会启动3个实例；如果其中1个挂了，K8s 会自动补1个，永远保持3个。

### ✅ 2.3 K8s 三大核心资源（Pod/Service/Deployment）【面试/工作 100% 必考，优先级极高】
> 重要前提：**K8s 不会直接管理容器，所有容器都运行在 Pod 中，Pod 是 K8s 管理的最小单位**，没有例外！

#### ✔️ 核心资源1：Pod（豆荚） - K8s 最小的部署/调度/管理单元，基石中的基石
##### ① 核心定义
Pod 是 K8s 创建和管理的**最小原子单元**，是一个「逻辑的主机」，里面可以封装**一个或多个紧密关联的容器**。
- 一个 Pod 内的所有容器：**共享同一个网络地址（IP）、共享存储、共享环境变量**，容器之间可以通过 localhost 互相访问；
- Pod 是**短暂的、一次性的**：Pod 挂了之后，K8s 会创建一个新的 Pod 替代它，**新 Pod 的 IP 会变**，这是 Pod 的核心特性。

##### ② 核心特点
1. 最小调度单位：K8s 不会把容器调度到节点，而是把 Pod 调度到节点；
2. 生命周期短暂：Pod 重启/重建后，IP 会发生变化；
3. 容器亲和性：一个 Pod 内的容器，一定运行在同一个节点上。

#### ✔️ 核心资源2：Deployment - 无状态应用的「控制器」，管理 Pod 的全生命周期
##### ① 为什么需要 Deployment？
Pod 是短暂的，直接创建的 Pod 挂了之后不会自动重建，而且无法实现「扩缩容、滚动更新、版本回滚」等核心功能，**生产环境绝对不能直接创建 Pod**。

##### ② 核心定义
Deployment 是 K8s 中最常用的**控制器（Controller）**，它的核心职责就是：**管理 Pod 的创建、副本数量、扩缩容、滚动更新、版本回滚**，保证 Pod 始终处于「期望的状态」。
> 关系：`Deployment → 管理 → Pod`，Deployment 是 Pod 的「管理者」，Pod 是 Deployment 的「实例」。

##### ③ 核心能力（生产必备，面试必问）
1. **副本管理**：声明需要 N 个 Pod 副本，Deployment 会自动创建并维持 N 个，少了补、多了删；
2. **弹性扩缩容**：一键调整 Pod 副本数（比如从3个扩到10个），应对流量高峰；
3. **滚动更新**：更新应用版本时，先启动新 Pod，再删除旧 Pod，**零停机更新**，不影响业务；
4. **版本回滚**：更新失败时，一键回滚到上一个稳定版本；
5. **自愈能力**：Pod 挂了、节点宕机了，Deployment 会自动在其他节点重建 Pod。

#### ✔️ 核心资源3：Service - 为 Pod 提供「稳定的访问入口」，解决 Pod IP 动态变化的痛点
##### ① 核心痛点（Service 诞生的原因）
Pod 的 IP 是动态的，Pod 重建后 IP 会变，如果服务之间直接通过 Pod IP 调用，会导致调用失败，这是 K8s 中最核心的网络问题。

##### ② 核心定义
Service 是 K8s 中**用于暴露 Pod 服务的资源**，它的核心作用是：**为一组具有相同功能的 Pod（比如 Deployment 管理的 Pod）提供一个「固定的、不变的虚拟IP（ClusterIP）」和访问端口**，外部/内部服务通过这个固定IP访问 Pod，无需关心 Pod 的实际IP和数量。

##### ③ 核心关系 & 原理
`Pod → 被 Service 标签选择器选中 → Service 提供固定访问地址`
1. Service 通过「标签选择器（Label Selector）」关联到一组 Pod；
2. 不管 Pod 怎么重建、扩缩容、IP怎么变，Service 的 IP 永远不变；
3. Service 会自动做负载均衡：将请求均匀分发到关联的所有 Pod 上。

##### ④ 核心特点
1. Service 的 IP 是**集群内唯一的、固定的**（ClusterIP），只在集群内部访问；
2. 支持负载均衡、会话保持；
3. 自动关联 Pod，Pod 扩缩容后，Service 会自动感知并更新后端列表。

#### ✔️ 三者核心关系总结（必背，灵魂公式，面试必考）
```
Deployment 管理 Pod（保证Pod数量+版本） → Service 为 Pod 提供稳定访问入口
```
> 一句话理解：**Deployment 负责 Pod 的「生死」，Service 负责 Pod 的「访问」**，三者相辅相成，是 K8s 最核心的黄金组合，生产环境99%的应用都是基于这三者部署的。

### ✅ 2.4 K8s 核心资源的 YAML 编写（最简实战版，够用）
K8s 中所有资源的创建，都是通过编写 **YAML 文件** 声明，然后执行 `kubectl apply -f xxx.yaml` 创建，下面是三者的组合式 YAML，最贴近生产实际：
```yaml
# 1. Deployment 配置：管理Pod
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
spec:
  replicas: 3  # 声明需要3个Pod副本
  selector:
    matchLabels:
      app: my-app  # 标签选择器，关联下面的Pod
  template:
    metadata:
      labels:
        app: my-app  # Pod的标签，和Service关联
    spec:
      containers:
      - name: my-app
        image: my-app:1.0
        ports:
        - containerPort: 8080

--- # 分隔符，一个YAML文件可以写多个资源
# 2. Service 配置：为Pod提供稳定访问
apiVersion: v1
kind: Service
metadata:
  name: my-app-service
spec:
  selector:
    app: my-app  # 关联标签为app=my-app的Pod
  ports:
  - port: 80     # Service的端口
    targetPort: 8080  # Pod的端口
  type: ClusterIP  # 默认类型，集群内访问的固定IP
```

---

## 三、K8s 集群部署与运维（核心流程+高频运维命令，工作必备）
### ✅ 3.1 K8s 集群的核心架构（必记，基础认知）
K8s 集群是**主从架构（Master + Node）**，所有的集群都是由「一个Master节点 + 多个Node节点」组成，分工明确，各司其职：
#### ✔️ Master 节点（控制平面/大脑）
集群的「控制中心」，负责**全局决策、调度、管理整个集群**，不运行业务容器，核心组件：
- `kube-apiserver`：集群的统一入口，所有操作都通过它执行；
- `kube-controller-manager`：集群的控制器，负责Pod自愈、副本管理等；
- `kube-scheduler`：调度器，负责把Pod调度到合适的Node节点；
- `etcd`：集群的「数据库」，存储集群所有的资源配置和状态数据（核心，分布式存储）。

#### ✔️ Node 节点（工作节点/干活的）
集群的「工作机器」，可以是物理机/虚拟机，负责**运行业务容器（Pod）**，所有的业务负载都运行在Node节点上，核心组件：
- `kubelet`：Node节点的代理，接收Master的指令，管理本机的Pod；
- `kube-proxy`：负责节点的网络代理，实现Service的负载均衡；
- `容器运行时`：比如Docker，负责运行容器。

### ✅ 3.2 K8s 集群部署（主流方案，生产/测试区分）
#### ✔️ 方案1：测试环境/学习环境 - 单节点部署（快速上手，推荐）
适合本地学习、开发测试，无需多节点，一键部署：
- **Minikube**：最流行的单机K8s集群工具，支持Windows/Mac/Linux，一键启动单节点集群；
- **Kind**：基于Docker容器模拟K8s节点，轻量、启动快，适合本地测试。

#### ✔️ 方案2：生产环境 - 多节点集群部署（主流2种，必知）
生产环境要求高可用、高性能，必须部署多节点集群，2种主流方案：
1. **kubeadm 部署**：K8s官方推荐的部署工具，轻量、简洁，适合中小型集群，**生产环境最常用**，核心命令：`kubeadm init`（初始化Master） + `kubeadm join`（Node节点加入集群）；
2. **二进制部署**：手动下载所有组件的二进制包，手动配置启动，最灵活、最稳定，适合大型企业级集群，缺点是配置繁琐。

> 补充：云厂商（阿里云/腾讯云/AWS）提供「托管式K8s集群」，无需手动部署，直接购买使用，企业首选。

### ✅ 3.3 K8s 核心运维命令（kubectl 命令，和docker命令对应，必会，高频）
kubectl 是 K8s 的**命令行工具**，所有的集群操作都通过 kubectl 执行，语法风格和 docker 很像，**核心格式**：`kubectl [命令] [资源类型] [资源名] [参数]`，下面是按使用频率排序的核心命令，工作/面试100%用到：
```bash
# ========== 1. 集群状态查看 ==========
kubectl get nodes          # 查看集群所有节点状态（Ready=正常）
kubectl cluster-info       # 查看集群信息（Master地址、K8s版本）

# ========== 2. 核心资源操作（重中之重，和Docker对应） ==========
kubectl get pods           # 查看所有Pod的状态（Running=正常）
kubectl get deployment     # 查看所有Deployment
kubectl get service        # 查看所有Service（ClusterIP=服务地址）

kubectl describe pod Pod名 # 查看Pod详情（排查Pod启动失败的核心命令！）
kubectl logs Pod名         # 查看Pod日志（排查业务报错）
kubectl logs -f Pod名      # 实时滚动查看Pod日志

kubectl exec -it Pod名 -- /bin/bash # 进入Pod内部（调试必备）

# ========== 3. 应用部署/更新/扩缩容/删除 ==========
kubectl apply -f xxx.yaml  # 部署应用（创建资源，核心命令，推荐）
kubectl delete -f xxx.yaml # 删除应用（删除资源）

kubectl scale deployment 应用名 --replicas=5 # 一键扩缩容（3个Pod→5个）

kubectl rollout restart deployment 应用名 # 重启应用（滚动重启，零停机）
kubectl rollout history deployment 应用名 # 查看更新历史
kubectl rollout undo deployment 应用名    # 版本回滚（核心，更新失败时用）

# ========== 4. 自愈/重启 ==========
kubectl delete pod Pod名   # 删除Pod，Deployment会自动重建（自愈）
kubectl restart pod Pod名  # 重启Pod
```

### ✅ 3.4 K8s 集群核心运维关注点（生产必备，面试高频）
1. **节点状态**：确保所有节点都是 `Ready` 状态，节点宕机后，Pod会自动调度到其他节点；
2. **Pod状态**：确保Pod都是 `Running` 状态，常见异常：`Pending`（调度失败）、`CrashLoopBackOff`（容器启动失败）、`ImagePullBackOff`（镜像拉取失败）；
3. **资源监控**：监控节点的CPU、内存使用率，Pod的资源占用，避免资源不足导致服务不可用；
4. **日志收集**：将Pod日志收集到ELK/PLG等日志平台，方便排查问题；
5. **备份恢复**：定期备份etcd数据库（集群的核心数据），防止配置丢失。

---

## 四、Docker vs K8s 核心区别（必记，面试必考）
很多人会混淆两者的关系，最后做一个清晰的总结，一句话讲透：
1. **定位不同**：Docker 是「容器化技术」，负责**打包应用为容器、单机管理容器**；K8s 是「容器编排平台」，负责**集群化管理成千上万的容器**；
2. **层级不同**：Docker 是基础，K8s 是基于Docker（或其他容器运行时）的上层平台，K8s 依赖Docker运行容器；
3. **能力不同**：Docker 能解决「单机容器管理」，K8s 能解决「集群容器的调度、扩缩容、自愈、负载均衡、滚动更新」等Docker解决不了的问题；
4. **使用场景**：单机/小规模应用 → Docker + Docker Compose；分布式/大规模/生产级应用 → K8s。

---

## 总结（核心知识点提炼，快速复习）
### Docker 核心
1. 三大组件：镜像（只读模板）、容器（运行实例）、仓库（镜像存储）；
2. 镜像制作：Dockerfile 编写 + docker build 构建；
3. 容器管理：docker run/ps/stop/rm/logs/exec 核心命令；
4. 多容器编排：Docker Compose + docker-compose.yml 一键管理多容器。

### K8s 核心
1. 三大核心资源：Pod（最小单位）、Deployment（管理Pod）、Service（稳定访问）；
2. 核心关系：Deployment → 管理 Pod，Service → 暴露 Pod；
3. 集群架构：Master（控制）+ Node（工作）；
4. 核心命令：kubectl get/apply/delete/logs/exec/scale 核心运维命令。

### 技术选型
- 开发/测试/单机：Docker + Docker Compose；
- 生产/集群/分布式：Kubernetes (K8s)。

以上就是 Docker + K8s 的全核心知识点，覆盖了你要求的所有内容，也是工作和面试的全部高频考点，掌握这些内容，足以应对绝大多数的容器化和K8s相关工作！

