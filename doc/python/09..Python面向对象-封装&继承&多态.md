


# Python面向对象的三大特征



Python 面向对象编程，这是 Python 编程的核心思想之一，它通过类（Class）和实例（Instance / 对象）来封装数据和行为，提高代码的可复用性和可维护性。

> 1、封装：
>
> 封装是面向对象的核心思想，它将对象的特征和行为封装起来，隐藏内部实现细节，只暴露必要的接口给外部使用。封装的主要目的是提高代码的安全性和可维护性。通过封装，可以合理隐藏对象的内部状态和方法，只提供必要的访问和修改数据的接口，从而防止外部直接访问和修改对象的内部数据，保护对象的数据安全。例如，一个银行账户类可能会封装账户的余额、交易记录等敏感信息，只提供存款、取款等安全的操作接口
>
> **核心：隐藏内部细节，提高程序安全性（健壮性）**
>
> 2、继承：
>
> 继承描述了类与类之间的关系，通过继承，可以在无需重新编写原有类的情况下，对原有类的功能进行扩展。子类可以继承父类的属性和方法，并可以添加新的属性和方法以扩展功能。继承提高了代码的复用性，减少了代码冗余。例如，汽车类定义了汽车的基本特性和功能，而轿车类可以继承汽车类，并添加特定的功能如天窗、导航等。
>
> **实现继承表示这个类拥有了被继承类的所有公有成员和受保护成员，被继承的类称为父类和基类，新的类称为子类或派生类。**
>
> **作用是：实现代码的复，通过继承可以理顺类与类之间得关。**
>
> 3、多态
>
> 多态指的是同一操作用于不同的对象会产生不同的执行结果。多态提高了代码的灵活性和可扩展性。通过多态，可以根据对象的实际类型调用相应的方法，实现了动态绑定。例如，不同的动物类（如狗、猫）都可能有叫的方法，但具体实现不同。多态允许根据实际对象类型调用不同的实现。
>

## 1、封装


```python
class Student:
    def __init__(self, name, age):
        self.__name = name
        self.__age = age

    def show(self):
        print(f'我叫{self.__name},我今年{self.__age}岁了')


if __name__ == '__main__':

    stu = Student("小美", -23)
    stu.show()
```
运行结果：
```java
我叫小美,我今年-23岁了
```


**说明：程序运行没有报错，但是运行结果不符合实际情况，年龄被赋予了负数，不正确的值**


```python
class Student:
    def __init__(self, name):
        self.__name = name

    # 用@property修饰过之后可以将方法当成属性来使用，使用时不需要加括号
    @property
    def age(self):  # 设置只读属性
        return self.__age

    # 设置赋值操作
    @age.setter
    def age(self, value):
        if value < 0 or value > 130:
            print("警告：输入的年龄不再正确范围之内，正确范围应该为0-130之间，默认值为18")
            self.__age = 18  # 超出0-130，则设置默认显示值18
        else:
            self.__age = value

    def show(self):
        print(f'我叫{self.__name},我今年{self.__age}岁了')


if __name__ == '__main__':
    stu = Student("小美")
    stu.age = -23
    print(stu.age)  # 用@property修饰过之后age方法，可以当成属性来使用，使用时不需要加括号

```
运行结果：
```java
警告：输入的年龄不再正确范围之内，正确范围应该为0-130之间，默认值为18
18
```

属性设置了私有，但是在某些情况下我们还是要访问或者赋值。所以必须要有解决的方法。
### get和set方法
在Java中对应有get和set方法，用于访问和赋值私有属性！其实Python中并没有get和set方法的。下面这个是自己定义的，并非系统自带。但是我们可以借鉴这种编程的思想！
```java
class Person:
    def __init__(self, name, age):
        self.__name = name
        self.__age = age

    def get_name(self):
        return self.__name

    def get_age(self):
        return self.__age

    def set_name(self, name):
        self.__name = name

    def set_age(self, age):
        self.__age = age


# 创建对象并传参
p = Person("小明", 20)

# 重新赋值name
p.set_name("小红")
print(p.get_name(), p.get_age())  # 输出小红,20
```

## 2、继承

### 2.1、类的继承

通过下面的例子，重点理解：
- 父类中已经定义了name，和age，在子类中可以直接调用；
- 使用super或类名可以调用父类的初始化方法，但是使用场景有时会不同。


```python
class Person:
    def __init__(self, name, age):
        self.__name = name
        self.__age = age

    def show(self):
        print(f'我叫{self.__name},我今年{self.__age}岁了')


# 子类
# Student类继承Person类
class Student(Person):
    def __init__(self, name, age, stuid):  # stuid，学号
        # 父类中已经定义了name，和age，在这里调用即可
        # 使用super调用父类的初始化方法，也可以使用类名，下面代码使用类名
        super().__init__(name, age)
        self.stuid = stuid  # 学生特有的属性学号赋值


# 子类
# Doctor类继承Person类
class Doctor(Person):
    def __init__(self, name, age, department):  # department，科室
        # 使用类名调用父类的初始化方法
        Person.__init__(self, name, age)
        self.department = department  # 医生特有的属性，科室


if __name__ == '__main__':
    # 创建Student类的对象
    stu = Student("小美", 20, "stu0007")
    # 调用父类的show方法
    stu.show()

    # 创建Doctor类的对象
    doctor = Doctor("张医生", 30, "外科")
    # 调用父类的show方法
    doctor.show()

```
运行结果：
```java
我叫小美,我今年20岁了
我叫张医生,我今年30岁了
```


### 2.2、多继承

在本例中，重点理解：
- 多继承：一个子类可以有多个直接父类，这样就具备了 “多个父类” 的特点
- 多继承中不能使用super，只能通过类名调用父类方法。


```python
class FatherA():
    def __init__(self, name):
        self.name = name

    def showA(self):
        print(f"我叫{self.name}")


class FatherB():
    def __init__(self, age):
        self.age = age

    def showB(self):
        print(f"我今年{self.age}岁了")


# 这里继承了FatherA和FatherB两个类的方法和属性
class Son(FatherA, FatherB):
    def __init__(self, name, age, gender):  # gender,性别

        # 这是只能使用类名调用父类方法，多继承中不能使用super调用类属性
        FatherA.__init__(self, name)  # 给name赋值
        FatherB.__init__(self, age)  # 给age赋值
        self.gender = gender

    def showS(self):
        print(f"我的性别是{self.gender}")


if __name__ == '__main__':
    son = Son("小美", 20, "女")
    son.showA()  # 调用父类FatherA的方法
    son.showB()  # 调用父类FatherB的方法
    son.showS()  # 调用自己的方法

```
运行结果：
```java
我叫小美
我今年20岁了
我的性别是女
```


### 2.3、方法重写

- 当父类（基类）中的某个方法不完全适合子类（派生类）时，就需要在子类中重写父类的方法；
- 子类重写后的方法中可 以通过`super().xxx()` 调用父类中被重写的方法。


```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def show(self):
        print(f'我叫{self.name},我今年{self.age}岁了')


# 子类
# Student类继承Person类
class Student(Person):
    def __init__(self, name, age, stuid):  # stuid，学号
        # 父类中已经定义了name，和age，在这里调用即可
        # 使用super调用父类的初始化方法，也可以使用类名，下面代码使用类名
        super().__init__(name, age)
        self.stuid = stuid  # 学生特有的属性学号赋值

    # 重写父类方法
    # 方法名和父类中的完全相同
    def show(self):
        # 可以调用父类的show方法，也可以重写

        # 调用父类方法
        super().show()
        # 补充自己的个性化的内容
        print(f'我的学号是{self.stuid}')


# 子类
# Doctor类继承Person类
class Doctor(Person):
    def __init__(self, name, age, department):  # department单词，科室
        # 使用类名调用父类的初始化方法
        Person.__init__(self, name, age)
        self.department = department  # 医生特有的属性，科室

    def show(self):
        # 重写父类中的show方法
        print(f'我是{self.name},我今年{self.age}岁了，我的科室是{self.department}')


if __name__ == '__main__':
    # 创建Student类的对象
    stu = Student("小美", 20, "stu0007")
    # 调用父类的show方法
    stu.show()

    # 创建Doctor类的对象
    doctor = Doctor("张医生", 30, "外科")
    # 调用父类的show方法
    doctor.show()

```
运行结果：
```java
我叫小美,我今年20岁了
我的学号是stu0007
我是张医生,我今年30岁了，我的科室是外科
```


## 3、object类的介绍

- object类是所有类的父类，因此所有类都有object类的属性和方法。

- 内置函数`dir()`可以查看指定对象所有属性

- object有一个`_str_()`方法，用于返回一个对于“对象的描述”，对应于内置函数`str()`经常用于`print()`方法，帮我们查看对象的信息，所以我们经常会对`_str_()`进行重写。

### 3.1、object类的属性和方法


```python
# dir查看object类的属性
print(dir(object))


print("-"*100)   # 分割线


# 所有的类都是继承了object类，所以下方的Person类中，括号里面的object可以默认不写
class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def show(self):
        print(f"大家好，我叫{self.name},今年{self.age}岁了")


if __name__ == '__main__':
    per = Person("小美", 20)
    per.show()

    # 使用dir()方法查看对象per的属性
    print(dir(per))
    print("-" * 100)  # 分割线
    # 从输出结果中我们可以看到：
    
    #dir(per)的输出比dir()多了几个: '__weakref__', 'age', 'name', 'show']，
    # 其实本质上是Person继承了object的方法，在输出dir()原有结果的基础上，后面加上了自己得方法。
```
运行结果：
```Python
['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']
----------------------------------------------------------------------------------------------------
大家好，我叫小美,今年20岁了
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'age', 'name', 'show']
----------------------------------------------------------------------------------------------------
```


### 3.2、重写__str__方法

在上面我们看到：`print(per)`和`print(per.__str__())`结果是相同的内存地址。结合下面得概念

>object有一个`_str_()`方法，用于返回一个对于“对象的描述”，对应于内置函数`str()`经常用于`print()`方法，帮我们查看对象的信息，所以我们经常会对`_str_()`进行重写。

可以得知，我们会经常查看对象的信息，所以我们接下来重写`__str__`方法：


```python
class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def show(self):
        print(f"大家好，我叫{self.name},今年{self.age}岁了")

    # 重写__str__方法
    def __str__(self):
        return "这个是一个人类，具有name和age两个实例属性"


if __name__ == '__main__':
    per = Person("小美", 20)
    per.show()
    print(per)  #当直接输出对象名是，默认调用__str__()方法
    print(per.__str__())

```
运行结果：
```java
大家好，我叫小美,今年20岁了
这个是一个人类，具有name和age两个实例属性
这个是一个人类，具有name和age两个实例属性
```


## 4、多态

- 简单地说，多态就是“具有多种形态”，它指的是：即便不知道一个变量所引用的对象到底是什么类型，仍然可以通过这个变量调用方法，在运行过程中根据变量所引用对象的类型，动态决定调用哪个对象中的方法

- Python语言的中多态，不关心对象的数据类型，不关心是否具有继承关系，只关心对象的行为 （方法）


```python
class Person():
    def eat(self):
        print("人，吃五谷杂粮")


class Cat():
    def eat(self):
        print("猫，喜欢吃鱼")


class Dog():
    def eat(self):
        print("狗，喜欢啃骨头")

# 以上三个不同的类，数据类型自然也是不同的，看似没有任何联系，但是他们都有一个同名的方法eat()
# 我们尝试看能否调用eat()方法：

def fun(obj):   #普通函数fun，obj是函数的形式参数
    obj.eat()   #调用eat方法，obj.eat这种写法，就注定他必须是一个具体的对象


if __name__ == '__main__':
    per = Person()   #创建Person类型的对象per
    cat = Cat()   #创建Cat类型的对象cat
    dog = Dog()   #创建Dog类型的对象dog

    # 调用fun函数
    fun(per)
    fun(cat)
    fun(dog

# Python中的多态只关心对象是否具有同名的方法,不管你是什么数据类型

```
运行结果：
```java
人，吃五谷杂粮
猫，喜欢吃鱼
狗，喜欢啃骨头
```

