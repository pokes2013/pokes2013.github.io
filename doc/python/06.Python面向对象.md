# 05.Python面向对象

‍

## 类的组成

```Python
class Student:
    # 类属性
    school = "北京大学"

    # 初始化方法
    def __init__(self, name, age):
        self.name = name
        self.age = age

    # 实例属性的调用
    def show(self):
        print(f'我叫{self.name},今年{self.age}岁了！')

    # 类方法
    @classmethod
    def classff(cls):
        print("这是类方法，不能调用实例属性和实例方法")

    # 静态方法
    @staticmethod
    def staticff():
        print("这是静态方法，不能调用实例属性和实例方法")


stu = Student("小明", 16)
print(stu.name, stu.age, stu.school,Student.school)
stu.show()
stu.classff()
stu.staticff()

# 通过类名调用类方法和静态方法
Student.classff()  #调用类方法
Student.staticff()  #调用静态方法
# Student.show() 但是不能调用类中的普通方法，要想调用必须先创建对象

```

## 动态绑定属性和方法

```Python
class Student:
    # 类属性
    school = "中心学校"

    # 初始化方法
    def __init__(self, name, age):
        self.name = name
        self.age = age

    # 实例属性的调用
    def show(self):
        print(f'我叫{self.name},今年{self.age}岁了！')


stu1 = Student("小明", 16)
stu2 = Student("小红", 15)

print(stu1.name, stu1.age)
print(stu2.name, stu2.age)

# 动态绑定属性
stu1.sex = "男"
stu2.sex = "女"
print(stu1.name, stu1.age, stu1.sex)
print(stu2.name, stu2.age, stu2.sex)


# 动态绑定方法
def introduce():
    print("我是一个普通函数，我被动态绑定成为stu2的对象方法！")

stu2.pokes = introduce   # 绑定方法，introduce不能有括号

# 调用绑定的动态方法,调用要加上括号
stu2.pokes()    #我是一个普通函数，我被动态绑定成为stu2的对象方法！
```

## 权限控制

```Python
class Student():
    def __init__(self, name, age, sex):
        # 首尾双下划线，表示特殊的方法，系统定义
        self._name = name  # 以单下划线开头，表示是受保护的成员，只能类本身和子类访问
        self.__age = age  # 以双下划线开头，表示是私有的，只能类本身使用
        self.sex = sex  # 普通的实例属性，在类的外部和类的内部以及子类都可以访问

    def _pokes1(self):  # 表示受保护的方法
        print('子类和本身可以访问')

    def __pokes2(self):  # 私有方法
        print('只有定义的类本身可以访问')

    # 这是一个普通的实例方法，在类的外部使用对象名打点访问
    # #在类的内部，使用seLf打点访问
    def show(self):
        print('普通方法，都可以访问！')


if __name__ == '__main__':
    stu = Student('小明', 16, '男')
    print(stu._name)  # 小明
    # print(stu.__age),报错__age私有，出了这个类就无法访问

    stu._pokes1()
    #stu.__pokes2(),报错__pokes2私有，出了这个类就无法访问

```

## 封装

‍

```Python
class Student:
    def __init__(self, name):
        self.__name = name

    @property  # 通过@property修饰后的方法可以当成属性使用
    def age(self):  # 设置只读属性，
        return self.__age

    @age.setter  # 设置赋值操作
    def age(self, value):
        if value < 0 or value > 130:
            print('年龄不在正确的范围区间内，年龄区间0-130')
            self.__age = 18  # 设置默认值
        else:
            self.__age = value
          
  

    def show(self):
        print(f'我叫：{self.__name}今年{self.__age}岁.')


if __name__ == '__main__':
    stu = Student("小明")
    stu.age = -23
    print(stu.age)
    stu.show()
  
    stu.age = 20  
    stu.show()
```

在Java中对应有get和set方法，用于访问和赋值私有属性！其实Python中并没有get和set方法的。下面这个是自己定义的，并非系统自。但是我们可以借鉴这种编程的思想！

```Python
class Person:
    def __init__(self, name, age):
        self.__name = name
        self.__age = age

    def get_name(self):
        return self.__name

    def get_age(self):
        return self.__age

    def set_name(self, name):
        self.__name = name

    def set_age(self, age):
        self.__age = age


# 创建对象并传参
p = Person("小明", 20)

# 重新赋值name
p.set_name("小红")

print(p.get_name(), p.get_age())  # 输出小红,20
```

## 继承

### 2.1、类的继承

通过下面的例子，重点理解：

* 父类中已经定义了name，和age，在子类中可以直接调用；
* 使用super或类名可以调用父类的初始化方法，但是使用场景有时会不同。

```Python
class Person:
    def __init__(self, name, age):
        self.__name = name
        self.__age = age

    def show(self):
        print(f'我叫{self.__name},我今年{self.__age}岁了')


# 子类
# Student类继承Person类
class Student(Person):
    def __init__(self, name, age, stuid):  # stuid，学号
        # 父类中已经定义了name，和age，在这里调用即可
        # 使用super调用父类的初始化方法，也可以使用类名，下面代码使用类名
        super().__init__(name, age)
        self.stuid = stuid  # 学生特有的属性学号赋值


# 子类
# Doctor类继承Person类
class Doctor(Person):
    def __init__(self, name, age, department):  # department，科室
        # 使用类名调用父类的初始化方法
        Person.__init__(self, name, age)
        self.department = department  # 医生特有的属性，科室


if __name__ == '__main__':
    # 创建Student类的对象
    stu = Student("小美", 20, "stu0007")
    # 调用父类的show方法
    stu.show()  #我叫小美,我今年20岁了

    # 创建Doctor类的对象
    doctor = Doctor("张医生", 30, "外科")
    # 调用父类的show方法
    doctor.show() #我叫张医生,我今年30岁了

```

### 2.2、多继承

在本例中，重点理解：

* 多继承：一个子类可以有多个直接父类，这样就具备了 “多个父类” 的特点
* 多继承中不能使用super，只能通过类名调用父类方法。

‍

```Python
class FatherA():
    def __init__(self, name):
        self.name = name

    def showA(self):
        print(f"我叫{self.name}")


class FatherB():
    def __init__(self, age):
        self.age = age

    def showB(self):
        print(f"我今年{self.age}岁了")


# 这里继承了FatherA和FatherB两个类的方法和属性
class Son(FatherA, FatherB):
    def __init__(self, name, age, gender):  # gender,性别

        # 这是只能使用类名调用父类方法，多继承中不能使用super调用类属性
        FatherA.__init__(self, name)  # 给name赋值
        FatherB.__init__(self, age)  # 给age赋值
        self.gender = gender

    def showS(self):
        print(f"我的性别是{self.gender}")


if __name__ == '__main__':
    son = Son("小美", 20, "女")
    son.showA()  # 调用父类FatherA的方法，我叫小美
    son.showB()  # 调用父类FatherB的方法，我今年20岁了
    son.showS()  # 调用自己的方法，我的性别是女

```

### 2.3、方法重写

* 当父类（基类）中的某个方法不完全适合子类（派生类）时，就需要在子类中重写父类的方法；
* 子类重写后的方法中可 以通过`super().xxx()`​ 调用父类中被重写的方法。

```Python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def show(self):
        print(f'我叫{self.name},我今年{self.age}岁了')


# 子类
# Student类继承Person类
class Student(Person):
    def __init__(self, name, age, stuid):  # stuid，学号
        # 父类中已经定义了name，和age，在这里调用即可
        # 使用super调用父类的初始化方法，也可以使用类名，下面代码使用类名
        super().__init__(name, age)
        self.stuid = stuid  # 学生特有的属性学号赋值

    # 重写父类方法
    # 方法名和父类中的完全相同
    def show(self):
        # 可以调用父类的show方法，也可以重写

        # 调用父类方法
        super().show()
        # 补充自己的个性化的内容
        print(f'我的学号是{self.stuid}')


# 子类
# Doctor类继承Person类
class Doctor(Person):
    def __init__(self, name, age, department):  # department单词，科室
        # 使用类名调用父类的初始化方法
        Person.__init__(self, name, age)
        self.department = department  # 医生特有的属性，科室

    def show(self):
        # 重写父类中的show方法
        print(f'我是{self.name},我今年{self.age}岁了，我的科室是{self.department}')


if __name__ == '__main__':
    # 创建Student类的对象
    stu = Student("小美", 20, "stu0007")
    # 调用父类的show方法
    stu.show()  #我叫小美,我今年20岁了
				#我的学号是stu0007
			

    # 创建Doctor类的对象
    doctor = Doctor("张医生", 30, "外科")
    # 调用父类的show方法
    doctor.show()  #我是张医生,我今年30岁了，我的科室是外科

```

## 3、object类的介绍

* object类是所有类的父类，因此所有类都有object类的属性和方法。
* 内置函数`dir()`​可以查看指定对象所有属性
* object有一个`_str_()`​方法，用于返回一个对于“对象的描述”，对应于内置函数`str()`​经常用于`print()`​方法，帮我们查看对象的信息，所以我们经常会对`_str_()`​进行重写。

### 3.1、object类的属性和方法

```Python
# dir查看object类的属性
print(dir(object))


print("-"*100)   # 分割线


# 所有的类都是继承了object类，所以下方的Person类中，括号里面的object可以默认不写
class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def show(self):
        print(f"大家好，我叫{self.name},今年{self.age}岁了")


if __name__ == '__main__':
    per = Person("小美", 20)
    per.show()

    # 使用dir()方法查看对象per的属性
    print(dir(per))
    print("-" * 100)  # 分割线
    # 从输出结果中我们可以看到：
  
    #dir(per)的输出比dir()多了几个: '__weakref__', 'age', 'name', 'show']，
    # 其实本质上是Person继承了object的方法，在输出dir()原有结果的基础上，后面加上了自己得方法。
```

运行结果：

```Python
['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']
----------------------------------------------------------------------------------------------------
大家好，我叫小美,今年20岁了
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'age', 'name', 'show']
```

### 3.2、重写__str__方法

在上面我们看到：`print(per)`​和`print(per.__str__())`​结果是相同的内存地址。结合下面得概念

> object有一个`_str_()`​方法，用于返回一个对于“对象的描述”，对应于内置函数`str()`​经常用于`print()`​方法，帮我们查看对象的信息，所以我们经常会对`_str_()`​进行重写。

可以得知，我们会经常查看对象的信息，所以我们接下来重写`__str__`​方法：

```Python
class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def show(self):
        print(f"大家好，我叫{self.name},今年{self.age}岁了")

    # 重写__str__方法
    def __str__(self):
        return "这个是一个人类，具有name和age两个实例属性"


if __name__ == '__main__':
    per = Person("小美", 20)
    per.show()  #大家好，我叫小美,今年20岁了
    print(per)  #当直接输出对象名是，默认调用__str__()方法，这个是一个人类，具有name和age两个实例属性
    print(per.__str__())  #这个是一个人类，具有name和age两个实例属性

```

## 多态

* 简单地说，多态就是“具有多种形态”，它指的是：即便不知道一个变量所引用的对象到底是什么类型，仍然可以通过这个变量调用方法，在运行过程中根据变量所引用对象的类型，动态决定调用哪个对象中的方法
* Python语言的中多态，不关心对象的数据类型，不关心是否具有继承关系，只关心对象的行为 （方法）

```Python
class Person():
    def eat(self):
        print("人，吃五谷杂粮")


class Cat():
    def eat(self):
        print("猫，喜欢吃鱼")


class Dog():
    def eat(self):
        print("狗，喜欢啃骨头")

# 以上三个不同的类，数据类型自然也是不同的，看似没有任何联系，但是他们都有一个同名的方法eat()
# 我们尝试看能否调用eat()方法：

def fun(obj):   #普通函数fun，obj是函数的形式参数
    obj.eat()   #调用eat方法，obj.eat这种写法，就注定他必须是一个具体的对象


if __name__ == '__main__':
    per = Person()   #创建Person类型的对象per
    cat = Cat()   #创建Cat类型的对象cat
    dog = Dog()   #创建Dog类型的对象dog

    # 调用fun函数
    fun(per)
    fun(cat)
    fun(dog

# Python中的多态只关心对象是否具有同名的方法,不管你是什么数据类型

```

‍
