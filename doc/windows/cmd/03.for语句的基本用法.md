# 03.for语句的基本用法

# 一、基础语法

```bash
FOR %variable IN (set) DO command [command-parameters]    #cmd窗口中
FOR %%variable IN (set) DO command [command-parameters]		#批处理文件中
```

之所以要区分`cmd窗口`​和`批处理文件`​两种环境，是因为在这两种环境下，命令语句表现出来的行为虽然基本一样，但是在细节上还是稍有不同，最明显的一个差异就是：在cmd窗口中，for之后的形式变量I必须使用单百分号引用，即`%I`​；而在批处理文件中，引用形式变量I必须使用双百分号，即`%%I`​。为了方便起见，若不是特别强调，以下的讲解都以批处理文件环境为例。

我们先来看一下for语句的基本要素都有些什么：

* 1、for、in和do是for语句的关键字，它们三个缺一不可；
* 2、%%I是for语句中对形式变量的引用，就算它在do后的语句中没有参与语句的执行，也是必须出现的；
* 3、in之后，do之前的括号不能省略；
* 4、command1表示字符串或变量，command2表示字符串、变量或命令语句；

现在，你可能已经会写一个简单的for语句了，比如：

```bash
@echo off
for %%I in (bbs.bathome.net) do echo %%I
pause

结果：
bbs.bathome.net
请按任意键继续...
```

* for语句的形式变量I，可以换成26个字母中的任意一个，这些字母会区分大小写，也就是说，%%I和%%i会被认为不是同一个变量；形式变量I还可以换成其他的字符，但是，为了不与批处理中的%0～%9这10个形式变量发生冲突，请不要随意把%%I替换为%%0 ～%%9中的任意一个；
* in和do之间的command1表示的字符串或变量可以是一个，也可以是多个，每一个字符串或变量，我们称之为一个元素，每个元素之间，用空格键、跳格键、逗号、分号或等号分隔；
* for语句依次提取command1中的每一个元素，把它的值赋予形式变量I,带到do后的command2中参与命令的执行；并且每次只提取一个元素，然后执行一次do后的命令语句，而无论这个元素是否被带到command2中参与了command2的运行；当执行完一次do后的语句之后，再提取command1中的下一个元素，再执行一次command2，如此循环，直到command1中的所有元素都已经被提取完毕，该for语句才宣告执行结束；

其中，第3点是最为关键的，它描述了for语句的执行过程，是for语句的精髓所在，大家一定要牢记这一条，才能深刻理解更为复杂的for流程。

　　有了以上的基础，我们再来看一个例子，这个例子修改了一些东西，结果将大不一样：

```bash
@echo off
for %%I in (bbs,bathome,net) do echo %%I
pause

输入：

bbs
bathome
net
请按任意键继续. . .
```

==括号里面用逗号把单词隔开了，运行结果就发生了变化==  
每一行都从逗号处被切分，如果把 bbs.bathome.net 这个字符串中的点号换为空格、跳格或等号，执行结果将和example2的执行结果别无二致。

现在，我们来分析一下代码中for语句的执行过程：  
　　首先，for语句以逗号为分隔符，把 bbs,bathome.net 这个字符串切分成三个元素：bbs、bathome和cn，由此决定了do后的语句将会被执行3次；  
　　然后，第一次执行过程是这样的：先把 bbs 这个字符串作为形式变量I的值，带入do后的语句中加以执行，也就是执行 echo %%I 语句，此时的I值为bbs，因此，第一次执行的结果，将会在屏幕上显示bbs这个字符串；第二次执行和第一次执行的过程是一样的，只不过此时I的值已经被替换为command1中的第二个元素了，也就是 bathome 这个字符串；如此循环，当第三次echo执行完毕之后，整条for语句才算执行完毕，此时，将执行下一条语句，也就是pause命令。  
　　  
举例：检测当前硬盘都有哪些分区

```bash
@echo off
set str=c d e f g h i j k l m n o p q r s t u v w x y z
echo 当前硬盘的分区有：
for %%i in (%str%) do if exist %%i: echo %%i:
pause

输出结果：

当前硬盘的分区有：
c:
d:
e:
请按任意键继续. . .
```

# 二、高级应用for /f

想知道当前目录下都有哪些文件吗？请用下面的代码：

```bash
@echo off
for %%i in (*.*) do echo "%%i"
pause
```

想列出当前目录下所有的文本文件吗？

```bash
@echo off
for %%i in (*.txt) do echo "%%i"
pause
```

想列出只用两个字符作为文件名的文本文件吗？

```bash
@echo off
for %%i in (??.txt) do echo "%%i"
pause
```

注意：以上代码不能列出含有隐藏或系统属性的文件，加上+s属性，但是不加+h的文件是可以被简单的for显示出来的。

```bash
@echo off
attrib +s 1.txt
For  %%i in (*.txt) do Echo %%i
pause
```

　　所有的对象，无论是文件、窗体、还是控件，在所有的非机器语言看来，无外乎都是形如"c:\test.txt"、"CWnd"之类的文本信息；而所有的对象，具体的如ini文件中的某条配置信息、注册表中的某个键值、数据库中的某条记录……都只有转化为具有一定格式的文本信息，方可被代码识别、操控。可以说，编程的很大一部分工作，都是在想方设法绞尽脑汁如何提取这些文本信息。

　　而提取文本信息，则是for /f的拿手好戏：读取文件内容；提取某几行字符；截取某个字符片段；对提取到的内容再切分、打乱、杂糅……只要你所能想到的花样，for /f 都会想方设法帮你办到，因为，for /f 就是被设计成专门用于解析文本的。

　　先来看个例子。

假如有个文本文件test.txt，内容如下：

```bash
论坛的目标是：不求最大，但求最好，做最实用的批处理论坛。
论坛地址：bbs.bathome.net。
这里是：新手晋级的福地，高手论剑的天堂。
```

那么，将如下代码保存为test.cmd，并放在test.txt同一目录下运行，将会在屏幕上原样显示test.txt的内容：

```bash
@echo off
for /f %%i in (test.txt) do echo %%i
pause
```

这段代码，主要是让你树立这样一种观念：读取文本文件的内容

进阶话题：for /f 语句是把整个test.txt一次性显示出来的？

无论for语句做何种变化，它的执行过程仍然遵循基本的for流程：依次处理每个元素，直到所有的元素都被处理为止。只不过在for /f语句中，这里的元素是指文件中的==每一行==，也就是说，for /f 语句是==以行为单位==处理文本文件的。

```bash
@echo off
for /f %%i in (test.txt) do echo %%i&pause
pause

输出结果：

论坛的目标是：不求最大，但求最好，做最实用的批处理论坛。
请按任意键继续. . .
论坛地址：bbs.bathome.net。
请按任意键继续. . .
这里是：新手晋级的福地，高手论剑的天堂。
请按任意键继续. . .
请按任意键继续. . .
```

### 切分字符串的利器：delims

```bash
@echo off
for /f "delims=，" %%i in (test.txt) do echo %%i
pause

输入结果：
论坛的目标是：不求最大
论坛地址：bbs.bathome.net。
这里是：新手晋级的福地
请按任意键继续. . .
```

结果，你惊奇地发现，每行第一个逗号之后的所有内容都不见了（如果有不存在逗号的行，则保留原样），也就说，你成功地提取到了每行第一个逗号之前的所有内容！

**如果分隔符有多个**

```bash
@echo off
for /f "delims=.，" %%i in (test.txt) do echo %%i
pause

输出结果：
论坛的目标是：不求最大
论坛地址：bbs
这里是：新手晋级的福地
请按任意键继续...
```

### 定点提取：tokens

我一再强调 for /f 默认只能提取到第一节的内容，现在我们来思考一个问题：如果我要提取的内容不在第一节上，那怎么办？这回，就该轮到 tokens= 出马了。

tokens= 后面一般跟的是数字，如 tokens=2，也可以跟多个，但是每个数字之间用逗号分隔，如 tokens=3,5,8，它们的含义分别是：提取第2节字符串、提取第3、第5和第8节字符串。注意，这里所说的“节”，是由 delims= 这一开关划分的，它的内容并不是一成不变的。

```bash
尺有所短，寸有所长，学好批处理没商量，考虑问题复杂化，解决问题简洁化。
```

如果以逗号作为切分符号，就正好可以把“学好批处理没商量”化为单独的一“节”，结合上一节的讲解，我们知道，"delims=，" 这个开关是不可缺少的，而要提取的内容在以逗号切分的第3节上，那么，tokens= 后面的数字就应该是3了，最终的代码如下：

```bash
@echo off
for /f "delims=， tokens=3" %%i in (test.txt) do echo %%i
pause

运行结果：

学好批处理没商量
请按任意键继续. . .
```

如果我们现在要提取的不只一个“节”，而是多个，那又怎么办呢？比如，要提取以逗号切分的第2节和第5节字符串，是写成这样吗？

```bash
@echo off
for /f "delims=， tokens=2,5" %%i in (test.txt) do echo %%i
pause

运行结果：

寸有所长
请按任意键继续. . .
```

运行批处理后发现，执行结果只显示了第2节的内容，==第5节的字符没有显示出来==。

　　原来，echo 后面的 %%i 只接收到了 tokens=2,5 中第一个数值2所代表的那个字符串，而第二个数值5所代表的字符串因为没有变量来接收，所以就无法在执行结果中显示出来了。

　　那么，要如何接收 tokens= 后面多个数值所指代的内容呢？

　　for /f 语句对这种情况做如下规定：

　　如果 tokens= 后面指定了多个数字，如果形式变量为%%i，那么，第一个数字指代的内容用第一个形式变量%%i来接收，第二个数字指代的内容用第二个形式变量%%j来接收，第三个数字指代的内容用第三个形式变量%%k来接收……第N个数字指代的内容用第N个形式变量来接收，其中，形式变量遵循字母的排序，第N个形式变量具体是什么符号，由第一个形式变量来决定：如果第一个形式变量是%%i，那么，第二个形式变量就是%%j；如果第一个形式变量用的是%%x，那么，第二个形式变量就是%%y。

==如果第一个形式变量是%%a，第二个形式变量就是%%b。第三个以此类推。。。。==

你应该知道如何修改才能满足题目的要求了吧？修改结果如下：

```bash
@echo off
for /f "delims=， tokens=2,5" %%i in (test.txt) do echo %%i %%j
pause

运行结果：
寸有所长 解决问题简洁化。
请按任意键继续. . .
```

如果有这样一个要求：显示[txt2]中的内容，但是逗号要替换成空格，如何编写代码？结合上面所学的内容，稍加思索，你可能很快就得出了答案：

```bash
@echo off
for /f "delims=， tokens=1,2,3,4,5" %%i in (test.txt) do echo %%i %%j %%k %%l %%m
pause

运行结果：
尺有所短 寸有所长 学好批处理没商量 考虑问题复杂化 解决问题简洁化。
请按任意键继续. . .
```

　　写完之后，你可能意识到这样一个问题：假如要提取的“节”数不是5，而是10，或者20，或者更多，难道我也得从1写到10、20或者更多吗？有没有更简洁的写法呢？

　　答案是有的，那就是：如果要提取的内容是连续的多“节”的话，那么，连续的数字可以只写最小值和最大值，中间用短横连接起来即可，比如 tokens=1,2,3,4,5 可以简写为 tokens=1-5 。

　　还可以把这个表达式写得更复杂一点：tokens=1,2-5，tokens=1-3,4,5，tokens=1-4,5……怎么方便就怎么写吧。

大家可能还看到一种比较怪异的写法：

```bash
@echo off
for /f "delims=， tokens=1,*" %%i in (test.txt) do echo %%i %%j
pause
```

结果，第一个逗号不见了，取代它的是一个空格符号，其余部分保持不变。

　　其中奥妙就在这个==星号==上面。

　　tokens=后面所接的星号具备这样的功能：字符串从左往右被切分成紧跟在`*`​之前的数值所表示的节数之后，字符串的其余部分保持不变，整体被`*`​所表示的一个变量接收。

　　理论讲解是比较枯燥的，特别是为了严密起见，还使用了很多限定性的修饰词，导致句子很长，增加了理解的难度，我们还是结合[code12]来讲解一下吧。

　　内容被切分，切分符号为逗号，当切分完第一节之后，切分动作不再继续下去，因为 tokens=1,* 中，星号前面紧跟的是数字1；第一节字符串被切分完之后，其余部分字符串不做任何切分，整体作为第二节字符串，这样，字符串就被切分成了两节，分别被变量%%i和变量%%j接收。

以上几种切分方式可以结合在一起使用。不知道下面这段代码的含义你是否看得懂，如果看不懂的话，那就运行一下代码，然后反复揣摩，你一定会更加深刻地理解本节所讲解的内容的：

```bash
@echo off
for /f "delims=， tokens=1,3-4,*" %%i in (test.txt) do echo %%i %%j %%k %%l
pause

输出结果：
尺有所短 学好批处理没商量 考虑问题复杂化 解决问题简洁化。
请按任意键继续. . .
```

### 跳过无关内容，直奔主题：skip=n

很多时候，有用的信息并不是贯穿文本内容的始终，而是位于第N行之后的行内，为了提高文本处理的效率，或者不受多余信息的干扰，for /f 允许你跳过这些无用的行，直接从第N+1行开始处理，这个时候，就需要使用参数 skip=n，其中，n是一个正整数，表示要跳过的行数。例如：

```bash
@echo off
for /f "skip=2" %%i in (test.txt) do echo %%i
pause
```

这段代码将跳过头两行内容

### 忽略以指定字符打头的行：eol=

```bash
@echo off
for /f "eol=;" %%i in (test.txt) do echo %%i
pause
```

忽略以分号开头的行

### 如何决定该使用 for /f 的哪种句式？

for /f %%i in (……) do (……) 语句有好几种变形语句，不同之处在于第一个括号里的内容：有的是用单引号括起来，有的是用双引号包住，有的不用任何符号包裹，具体格式为：

* 1、for /f %%i in (文件名) do (……)
* 2、for /f %%i in ('命令语句') do (……)
* 3、for /f %%i in ("字符串") do (……)

如果你一时无法参透其中奥妙，那也无妨，请听我狡辩：  
　==1、当你希望读取文本文件中的内容的话，第一个括号中不用任何符号包裹，应该使用的是第1条语句；==例如：你想显示test.txt中的内容，那么，就使用 for /f %%i in (test.txt) do echo %%i；  
　==2、当你读取的是命令语句执行结果中的内容的话，第一个括号中的命令语句必须使用单引号包裹，应该使用的是第2条语句；==例如：你想显示当前目录下文件名中含有test字符串的文本文件的时候，应该使用 for /f %%i in ('dir /a-d /b *test*.txt') do echo %%i 这样的语句；  
　==3、当你要处理的是一个字符串的时候，第一个括号中的内容必须用双引号括起来，应该是用的是第3条语句；==例如：当你想把bbs.bathome.net这串字符中的点号换为短横线并显示出来的话，可以使用 for /f "delims=. tokens=1-3" %%i in ("bbs.bathome.net") do echo %%i-%%j-%%k 这样的语句。

　　很显然，第一个括号里是否需要用符号包裹起来，以及使用什么样的符号包裹，取决于要处理的对象属于什么类型：如果是文件，则无需包裹；如果是命令语句，则用单引号包裹；如果是字符串，则使用双引号括起来。

当然，事情并不是绝对如此，如果细心的你想到了批处理中难缠的特殊字符，你肯定会头大如斗。

　　或许你头脑中灵光一闪，已经想到了一个十分头痛的问题：在第1条语句中，如果文件名中含有空格或&，该怎么办？

```bash
@echo off
for /f %%i in ("test 1.txt") do echo %%i
pause
```

test 1.txt 文件名中有空格，一般人可能使用双引号包裹，如果包裹他就会识别为字符串，这个时候我们需要引入一个参数`usebackq`​。  
当使用了usebackq之后，如果第一个括号中是一条命令语句，那么，就要把单引号`'改成后引号，（键盘左上角esc键下面的那个按键，与~在同一键位上）。

usebackq 是一个增强型参数，当使用了这个参数之后，原来的for语句中第一个括号内的写法要做如下变动：

* 如果第一个括号里的对象是一条命令语句的话，原来的单引号'要改为后引号`；
* 如果第一个括号里的对象是字符串的话，原来的双引号"要改为单引号'；
* 如果第一个括号里的对象是文件名的话，要用双引号括起来。

我们来验证一下：

```bash
@echo off
for /f "usebackq" %%i in ("test 1.txt") do echo %%i
pause
```

测试通过！

　　此时，你很可能会仰天长叹：Shit，微软这该死的机器翻译！

　　至于把[code17]代码中的空格换成&后，CMD窗口会直接退出，那是因为&是复合语句的连接符，CMD在预处理的时候，会优先把&前后两部分作为两条语句来解析，而不是大家想象中的一条完整的for语句，从而产生了严重的语法错误。因为牵涉到预处理机制问题，不属于本节要讨论的内容，在此不做详细讲解。

　　这个时候，我们会吃惊地发现，区区一条for语句，竟然有多达6种句型：

　　1、for /f %%i in (文件名) do (……)  
　　2、for /f %%i in ('命令语句') do (……)  
　　3、for /f %%i in ("字符串") do (……)  
　　4、for /f "usebackq" %%i in ("文件名") do (……)  
　　5、for /f "usebackq" %%i in (`命令语句`​) do (……)  
　　6、for /f "usebackq" %%i in ('字符串') do (……)

　　其中，4、5、6由1、2、3发展而来，他们有这样的对应关系：1-->4、2-->5、3-->6。

　　好在后3种情形并不常用，所以，牢牢掌握好前三种句型的适用情形就可以了，否则，要在这么多句型中确定选择哪一条语句来使用，还真有点让人头脑发懵。

　　至于 for /f 为什么要增加usebacq参数，我只为第4条语句找到了合理的解释：为了兼容文件名中所带的空格或&。

# 三、遍历文件夹：for /r

for /r 的作用是“递归”，我们换一个通俗一点的，叫“遍历文件夹”。

```bash
@echo off
for /r d:\test %%i in (.) do echo %%i
pause

执行结果：
d:\test\.
d:\test\1\.
d:\test\2\.
d:\test\3\.
```

效果就是显示 d:\test 目录及其之下是所有子目录的路径，其效果与 dir /ad /b /s d:\test 类似。若要说到两者的区别，可以归纳出3点：

> 1、`for /r`​ 列举出来的路径最后都带有斜杠和点号，而 dir 语句则没有，会对获取到的路径进行进一步加工产生影响； 　　  
> 2、`for  /r`​ 不能列举带隐藏属性的目录，而 dir 语句则可以通过指定 /a 后面紧跟的参数来获取带指定属性的目录，更加灵活；  
> 3、若要对获取到的路径进行进一步处理，则需要把 dir 语句放入 for /f 语句中进行分析，写成 `for /f %%i in ('dir /ad /b /s') do ……`​ 的形式；由于 for /r语句是边列举路径边进行处理，所以，在处理大量路径的时候，前期不会感到有停顿，而 for /f 语句则需要等到 `dir /ad /b /s`​语句把所有路径都列举完之后，再读入内存进行处理，所以，在处理大量路径的时候，前期会感到有明显的停顿。

　　第2点差别很容易被大家忽视，导致用 for /r 列举路径的时候会造成遗漏；而第3点则会让大家有更直观的感受，很容易感觉到两者之间的差别。

要是“元素集合”不是点号呢？那又如何？

```bash
@echo off
for /r d:\test %%i in (a b c) do echo %%i
pause

运行结果：
D:\test\1\a
D:\test\1\b
D:\test\1\c
D:\test\2\a
D:\test\2\b
D:\test\2\c
D:\test\3\a
D:\test\3\b
D:\test\3\c

```

原来，它的含义是：列举 d:\test 及其所有的子目录，对所有的目录路径都分别添加a、b、c之后再显示出来。

列举 d:\test 及其所有子目录下的txt文本文件：

```bash
@echo off
for /r d:\test %%i in (*.txt) do echo %%i
pause
```

这段代码的含义是：列举 d:\test 及其所有子目录下的txt文本文件（以.txt结尾的文件夹不会被列出来）。

我们再回过头来归纳一下这个语句的作用：  
for /r 目录 %%i in (元素集合) do 命令语句集合

　　上面语句的作用是：

　　1、列举“目录”及该目录路径下所有子目录，并把列举出来的目录路径和元素集合中的每一个元素拼接成形如“目录路径\元素”格式的新字符串，然后，对每一条这样的新  
字符串执行“命令语句集合”中的每一条命令；  
　　特别的是：当“元素集合”带以点号分隔的通配符?或*的时候，把“元素集合”视为文件（不视为文件夹），整条语句的作用是匹配“目录”所指文件夹及其所有子文件夹下  
匹配的文件；若不以点号分隔，则把“元素集合”视为文件夹（不视为文件）；  
　　2、当省略掉“目录”时，则针对当前目录；  
　　3、当元素集合中仅仅是一个点号的时候，将只列举目录路径；

http://bbs.bathome.net/thread-2189-1-1.html
